# Problem Set 4b
import random

class Message(object):
    def __init__(self, input_text):
        '''
        - input_text:string, the message's text.
        ---
        #### return:
            Initializes a Message object.
        ---
        #### Note:
            Message object has one attribute: the message text.
        '''
        self.message = input_text

    def __repr__(self):
        '''
        ---
        #### return:
            string, a human readable representation of the object.
        ---
        #### DO NOT CHANGE.
        '''
        return f'''Message('{self.get_text()}')'''

    def get_text(self):
        '''
        ---
        #### return: 
            string, the message text.
        ---
        Used to access the message text outside of the class.
        '''
        return self.message

    def shift_char(self, char, shift):
        '''
        - char: string, the single character to shift.
                    ASCII value in the range: 32 <= ord(char) <= 126.
        - shift: int, the amount to shift char by.
        ---
        #### return: 
            string, the shifted character with ASCII value in the range [32, 126].
        ---
        Used to shift a character as described in the pset handout.
        '''
        value = ord(char) + shift
           
        # Loop: if 'value' is in range, return the char associated to the new ASCII value 
        while value in range(32, 127):
            return chr(value)
        
        return chr(32 + (value-32) % 95)

    def apply_pad(self, pad):
        '''
        - pad: a list of integers, used to encrypt the message text.
            len(pad) == len(the message text).
        ---
        #### return:
            string, the ciphertext produced using the one time pad.
        ---
        #### Note:
            For each character in the text at index i shift that character by the amount specified by pad[i].
        ---
        Used to calculate the ciphertext produced by applying a one time pad to the message text.
        '''
        if not self.message or not pad:
            return ''
        
        assert len(pad) == len(self.message), 'Pad length must match message length'
        
        char_shift = self.shift_char(self.message[0], pad[0])
        mess_remain = Message(self.message[1:])

        # Recursion: call apply_pad on the remaining message and the remaining pad
        return char_shift + mess_remain.apply_pad(pad[1:])

class PlaintextMessage(Message):
    def __init__(self, input_text, pad=None):
        '''
        - input_text: string, the message's text.
        - pad: list of ints or None, the pad to encrypt the input_text or 
            None if left empty. 
        ---
        #### return:
            A PlaintextMessage object inherits from Message. It has three attributes:
                the message text.
                the pad (list of integers, determined by pad or generated randomly using 
                self.generate_pad() if pad is None).
                the ciphertext (string, input_text encrypted using the pad).
        ---
        #### Note:
            If pad is not None then len(pad) == len(self.input_text).
        ---
        Initializes a PlaintextMessage object.
        ''' 
        super().__init__(input_text)
        
        if pad != None:
            assert len(pad) == len(self.message), 'Pad length must match message length'
            self.pad = pad.copy()
        
        else:
            self.pad = self.generate_pad()
        
        self.ciphertext = super().apply_pad(self.pad)

    def __repr__(self):
        '''
        ---
        #### return:
            string, a human readable representation of the object.
        ---
        #### DO NOT CHANGE.
        '''
        return f'''PlaintextMessage('{self.get_text()}', {self.get_pad()})'''

    def generate_pad(self):
        '''
        ---
        #### return: 
            list of integers, new one time pad.
        ---
        Generates a one time pad which can be used to encrypt the message text.\n
        The pad should be generated by making a new list and for each character 
        in the message chosing a random number in the range [0, 110) and
        adding that number to the list.
        '''
        # Loop: iterate over each value in self.message (input_text)
        return [random.randint(0, 109) for _ in self.get_text()]

    def get_pad(self):
        '''
        ---
        #### return:
            list of integers, COPY of your pad.
        ---
        Used to safely access your one time pad outside of the class.
        '''
        return self.pad.copy()

    def get_ciphertext(self):
        '''
        ---
        #### return:
            string, the ciphertext.
        ---
        Used to access the ciphertext produced by applying pad to the message text.
        '''
        return self.ciphertext

    def change_pad(self, new_pad):
        '''
        - new_pad: list of ints, new one time pad that should be associated with this message.
        ---
        #### return: 
            nothing
        ---
        #### Note:
            len(new_pad) == len(the message text).
        ---
        Changes the pad used to encrypt the message text and updates any other
        attributes that are determined by the pad.
        '''
        assert len(new_pad) == len(self.get_text()), 'Pad length must match message length'
        
        self.pad = new_pad.copy()
        self.ciphertext = super().apply_pad(self.pad)

class EncryptedMessage(Message):
    def __init__(self, input_text):
        '''
        - input_text: string, the ciphertext of the message.
        ---
        #### return:
            an EncryptedMessage object inherits from Message. It has one attribute:
                the message text (ciphertext).
        ---
        Initializes an EncryptedMessage object.
        '''
        super().__init__(input_text)

    def __repr__(self):
        '''
        ---
        #### return:
            string, a human readable representation of the object.
        ---
        #### DO NOT CHANGE.
        '''
        return f'''EncryptedMessage('{self.get_text()}')'''

    def decrypt_message(self, pad):
        '''
        - pad: list of ints, the new one time pad used to encrypt the message.
        ---
        #### return: 
            PlaintextMessage, the decrypted message (containing the pad).
        ---
        #### Note:
            len(pad) == len(the message text).
        ---
        Decrypts the message text that was encrypted with pad as described in the writeup.
        '''
        assert len(pad) == len(self.get_text()), 'Pad length must match message length'
        
        new_pad = [-e for e in pad]
        
        return PlaintextMessage(self.apply_pad(new_pad), pad)